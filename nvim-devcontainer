#!/usr/bin/env python3
import argparse
import os
import random
import string
import subprocess
import sys
import tempfile
from io import StringIO

from ruamel.yaml import YAML
from xdg_base_dirs import xdg_config_home


script_dir = os.path.dirname(os.path.realpath(__file__))


def random_string(length):
    charset = string.ascii_lowercase + string.digits
    return "".join(random.choice(charset) for _ in range(length))


def deep_merge(dict1, dict2):
    result = dict1.copy()
    for key, value in dict2.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result


class CommandError(Exception):
    pass


def build(base_image_name, tag, context_dir):
    with open(os.path.join(script_dir, "Dockerfile.amd64"), "r") as f:
        template_contents = f.read()

    new_dockerfile_contents = template_contents.replace("%%__BASE_IMAGE__%%", base_image_name)

    with tempfile.NamedTemporaryFile() as f:
        f.write(new_dockerfile_contents.encode())
        f.flush()
        tag = tag or f"{base_image_name}:nvim-devcontainer"
        cmd = ["docker", "build", "-t", tag, "-f", f.name, context_dir]
        print(" ".join(cmd))
        subprocess.run(cmd, check=True)

    print(f'Image "{tag}" is now available')


def compose(args):
    compose_file = os.path.join(args.directory, args.compose_file)
    compose_override_file = os.path.join(args.directory, args.compose_override_file)
    if not os.path.exists(args.compose_file):
        raise CommandError(f"File not found: {os.path.relpath(compose_override_file)}")

    yaml = YAML()

    # load source service from current docker-comose config
    if os.path.exists(compose_override_file):
        with open(compose_override_file) as f:
            compose_override_config = yaml.load(f)
    else:
        compose_override_config = yaml.load(StringIO("services:"))

    with open(compose_file) as f:
        comopse_config = yaml.load(f)

    # Create new service in compose_override_config using deep clone of source service
    source_service = comopse_config["services"][args.source_service]
    new_service = source_service.copy()
    
    # Update env vars in new service
    env = new_service.get("environment", [])
    if isinstance(env, dict):
        env_list: list = [f"{k}={v}" for k, v in env.items()]
    else:
        env_list: list = env
    env_list.extend([
      "COLORTERM",
      "ITERM_PROFILE",
      "ITERM_SESSION_ID",
      "LC_TERMINAL",
      "LC_TERMINAL_VERSION",
      "TERM",
      "TERM_PROGRAM",
      "TERM_PROGRAM_VERSION",
      "TERM_SESSION_ID",
    ])
    new_service["environment"] = env_list

    source_image = source_service.get("image")
    if source_image is None:
        project_name = os.path.basename(os.path.abspath(args.directory))
        source_image = f"{project_name}-{args.source_service}"

    new_service["image"] = f"{source_image}:nvim-devcontainer"

    build(source_image, new_service["image"], args.directory)

    new_service["stdin_open"] = True
    new_service["tty"] = True
    new_service["entrypoint"] = "nvim"

    ignore_keys = ["command", "build", "depends_on"]
    for key in ignore_keys:
        if key in new_service:
            del new_service[key]

    # Set up mountpoints
    get_config_path = lambda path: os.path.realpath(os.path.join(xdg_config_home(), path))
    new_service["volumes"] = new_service.get("volumes", [])
    new_service["volumes"].extend([
        # The XDG dirs will be changed in the docker image to point to these
        f"{get_config_path('nvim')}:/nvim-devcontainer/config/nvim:ro", 
        f"{get_config_path('.gitconfig')}:/nvim-devcontainer/config/nvim:ro", 
        f"{get_config_path('copilot')}:/nvim-devcontainer/config/github-copilot:ro",
        "nvim-data:/nvim-devcontainer/data/nvim",
    ])

    # Set up shared nvim-data volume
    compose_override_config["volumes"] = compose_override_config.get("volumes") or {}
    compose_override_config["volumes"] = {"nvim-data": {}}

    # Add the new service
    compose_override_config["services"] = compose_override_config.get("services") or {}
    compose_override_config["services"][args.name] = new_service

    with open(compose_override_file, "w") as f:
        yaml.dump(compose_override_config, f)

    print(f"Configured service '{args.name}' in {os.path.relpath(compose_override_file)}")


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="command")

    build_parser = subparsers.add_parser("build", help="Build devcontainer image")
    build_parser.add_argument("base_image", type=str, help="Base image to use")
    build_parser.add_argument("directory", type=str, help="Build context directory")

    compose_parser = subparsers.add_parser("compose", help="")
    compose_parser.add_argument("-s", "--source-service", type=str, help="", required=True)
    compose_parser.add_argument("--compose-file", type=str, default="docker-compose.yml",
                                help="Compose override file name (relative to project directory)")
    compose_parser.add_argument("--compose-override-file", type=str,
                                default="docker-compose.override.yml",
                                help="Compose override file name (relative to project directory)")
    compose_parser.add_argument("--name", type=str, default="vim", help="Name for new service")
    compose_parser.add_argument("directory", type=str, help="Compose project directory")

    args = parser.parse_args()

    if args.command == "build":
        tag = f"{args.base_image}:nvim-devcontainer"
        build(args.base_image, tag, args.directory)

    elif args.command == "compose":
        compose(args)


if __name__ == "__main__":
    try:
        main()
    except CommandError as e:
        sys.stderr.write(f"e.value\n")
        sys.exit(1)
